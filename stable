#include <Geode/Geode.hpp>
#include <Geode/modify/PlayLayer.hpp>
#include <Geode/modify/RetryLevelLayer.hpp>
#include <Geode/modify/EditLevelLayer.hpp>
#include <Geode/modify/LevelInfoLayer.hpp>
#include <Geode/modify/LevelSelectLayer.hpp>
#include <Geode/modify/FLAlertLayer.hpp>
#include <Geode/cocos/CCDirector.h>

using namespace geode::prelude;

class $modify(NoAutoRetryPlusPlayLayer, PlayLayer) {
public:
    struct Fields {
        bool deathScreenShown = false;
    };

private:
    bool isPracticeDeathScreenEnabled() const {
        auto mod = Mod::get();
        if (!mod) return true;
        if (!mod->hasSetting("practice-death-screen")) return true;
        return mod->getSettingValue<bool>("practice-death-screen");
    }

    bool isPracticeCursorForced() const {
        auto mod = Mod::get();
        if (!mod) return true;
        if (!mod->hasSetting("force-practice-cursor")) return true;
        return mod->getSettingValue<bool>("force-practice-cursor");
    }

    bool isDeathScreenBugFixEnabled() const {
        auto mod = Mod::get();
        if (!mod) return true;
        if (!mod->hasSetting("fix-death-screen-bug")) return true;
        return mod->getSettingValue<bool>("fix-death-screen-bug");
    }

public:
    // Shared logic to actually spawn the layer
    void createRetryLayer() {
        // If the fix is ENABLED, we strictly enforce the flag.
        // If DISABLED, we bypass this check to allow multiple screens (the bug).
        if (isDeathScreenBugFixEnabled()) {
            if (!m_fields->deathScreenShown) return;
        }

        // Standard safety checks (must always apply)
        if (!m_isPracticeMode) return;
        if (!m_player1 || !m_player1->m_isDead) {
            m_fields->deathScreenShown = false;
            return;
        }

        auto layer = RetryLevelLayer::create();
        if (!layer) {
            m_fields->deathScreenShown = false;
            return;
        }

        this->addChild(layer, 100);
        layer->enterLayer();

        if (isPracticeCursorForced()) {
            if (auto director = cocos2d::CCDirector::sharedDirector()) {
                if (auto gl = director->getOpenGLView()) {
#ifdef GEODE_IS_WINDOWS
                    gl->showCursor(true);
#endif
                }
            }
        }
    }

    // Called by scheduleOnce (Clean behavior)
    void onPracticeDeathDelay(float dt) {
        if (!isPracticeDeathScreenEnabled()) {
            m_fields->deathScreenShown = false;
            return;
        }
        createRetryLayer();
    }

    // Called by runAction (Buggy behavior)
    void onPracticeDeathDelayCallFunc() {
        if (!isPracticeDeathScreenEnabled()) {
            m_fields->deathScreenShown = false;
            return;
        }
        createRetryLayer();
    }

    void resetLevel() {
        this->unschedule(schedule_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelay));
        this->stopActionByTag(0xDEAD); // Stop the buggy action if it exists
        m_fields->deathScreenShown = false;
        PlayLayer::resetLevel();
    }

    void resetLevelFromStart() {
        this->unschedule(schedule_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelay));
        this->stopActionByTag(0xDEAD);
        m_fields->deathScreenShown = false;
        PlayLayer::resetLevelFromStart();
    }

    void onQuit() {
        this->unschedule(schedule_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelay));
        this->stopActionByTag(0xDEAD);
        m_fields->deathScreenShown = false;
        PlayLayer::onQuit();
    }

    void togglePracticeMode(bool on) {
        this->unschedule(schedule_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelay));
        this->stopActionByTag(0xDEAD);
        m_fields->deathScreenShown = false;
        PlayLayer::togglePracticeMode(on);
    }

    void showRetryLayer() {
        if (m_player1 && !m_player1->m_isDead) {
            return;
        }

        if (!m_isPracticeMode || !isPracticeDeathScreenEnabled()) {
            PlayLayer::showRetryLayer();
            return;
        }

        // Fix Enabled: Use checks and scheduleOnce (Safe)
        if (isDeathScreenBugFixEnabled()) {
            if (m_fields->deathScreenShown) {
                return;
            }
            m_fields->deathScreenShown = true;
            
            this->scheduleOnce(
                schedule_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelay),
                0.4f
            );
        }
        // Fix Disabled: Use CCAction (Unsafe/Stackable)
        else {
            m_fields->deathScreenShown = true; // Still needed to block delayedResetLevel
            
            auto delay = CCDelayTime::create(0.4f);
            auto call = CCCallFunc::create(this, callfunc_selector(NoAutoRetryPlusPlayLayer::onPracticeDeathDelayCallFunc));
            auto sequence = CCSequence::create(delay, call, nullptr);
            sequence->setTag(0xDEAD); // Tag it so we can try to cancel it on reset
            this->runAction(sequence);
        }
    }

    void delayedResetLevel() {
        if (m_isPracticeMode &&
            isPracticeDeathScreenEnabled() &&
            m_fields->deathScreenShown) {
            return;
        }
        PlayLayer::delayedResetLevel();
    }

    void destroyPlayer(PlayerObject* player, GameObject* object) {
        PlayLayer::destroyPlayer(player, object);

        if (m_isPracticeMode &&
            isPracticeDeathScreenEnabled()) {

            if (!isDeathScreenBugFixEnabled() || !m_fields->deathScreenShown) {
                this->showRetryLayer();
            }
        }
    }
};

// --- Helper for Up Arrow Remapping ---

bool shouldMapUpArrow(cocos2d::enumKeyCodes key) {
    if (key != cocos2d::enumKeyCodes::KEY_Up) return false;

    auto mod = Mod::get();
    if (!mod || !mod->hasSetting("up-arrow-retry")) return true;

    return mod->getSettingValue<bool>("up-arrow-retry");
}

// --- Input Hooks ---

class $modify(NoAutoRetryPlusRetryLevelLayer, RetryLevelLayer) {
public:
    void keyDown(cocos2d::enumKeyCodes key) override {
        if (shouldMapUpArrow(key)) {
            key = cocos2d::enumKeyCodes::KEY_Space;
        }
        RetryLevelLayer::keyDown(key);
    }
};

class $modify(NoAutoRetryPlusLevelInfoLayer, LevelInfoLayer) {
public:
    void keyDown(cocos2d::enumKeyCodes key) override {
        if (shouldMapUpArrow(key)) {
            key = cocos2d::enumKeyCodes::KEY_Space;
        }
        LevelInfoLayer::keyDown(key);
    }
};

class $modify(NoAutoRetryPlusLevelSelectLayer, LevelSelectLayer) {
public:
    void keyDown(cocos2d::enumKeyCodes key) override {
        if (shouldMapUpArrow(key)) {
            key = cocos2d::enumKeyCodes::KEY_Space;
        }
        LevelSelectLayer::keyDown(key);
    }
};

class $modify(NoAutoRetryPlusEditLevelLayer, EditLevelLayer) {
public:
    void keyDown(cocos2d::enumKeyCodes key) override {
        if (shouldMapUpArrow(key)) {
            key = cocos2d::enumKeyCodes::KEY_Space;
        }
        EditLevelLayer::keyDown(key);
    }
};

class $modify(NoAutoRetryPlusFLAlertLayer, FLAlertLayer) {
public:
    void keyDown(cocos2d::enumKeyCodes key) override {
        if (shouldMapUpArrow(key)) {
            key = cocos2d::enumKeyCodes::KEY_Space;
        }
        FLAlertLayer::keyDown(key);
    }
};
